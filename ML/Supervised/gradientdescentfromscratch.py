# -*- coding: utf-8 -*-
"""GradientDescentFromScratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sZUp0L9VXv18u1R2J8Mryrrb3gXr_cMh
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression

df = pd.read_csv(r'D:\CODING_CODES\AIML\ML\Supervised\Data\LinearRegression.csv')

df.head()

X = df[['cgpa']]
y = df['package']

plt.scatter(X,y)
plt.show()

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=3)

# Ordinary Least Squared (OLS) method

lr = LinearRegression()

lr.fit(X_train,y_train)

m = lr.coef_
print(m)

b = lr.intercept_
print(b)

plt.scatter(X,y)
plt.plot(X_train,lr.predict(X_train),color='red')
plt.show()

# Parameters by OLS:
mOLS = lr.coef_
bOLS = lr.intercept_

# Gradient Descent

# Cost function
# L = sum((y-yPred)^2)
# L = sum((y-mx-b)^2)

# dL/db = -2*sum(y-mx-b)
# dL/dm = -2*sum((y-mx-b)*x)

# bNew = bOld - (learningRate * dL/db)
# mNew = mOld - (learningRate * dL/dm)

# learning rate: Constant hyperparameter
# epochs: Number of iterations

class GD:
  def __init__(self,m,b,learning_rate,epochs):
    self.m = m  # initial slope
    self.b = b  # initial intercept
    self.lrate = learning_rate
    self.epochs = epochs

  def fit(self,X,y):
    for i in range(self.epochs):
      slope_b = -2*np.sum(y- self.m*X.ravel() - self.b)
      slope_m = -2*np.sum((y- self.m*X.ravel()- self.b)*X.ravel())
      self.b = self.b - self.lrate*slope_b
      self.m = self.m - self.lrate*slope_m
      print(f"Slope={self.m}, intercept={self.b}")
  def predict(self,x):
    return self.m * x + self.b
  def getParameters(self):
    return self.m,self.b

gd = GD(0,0,0.00005,20000)

train_data_X = X_train.to_numpy()
test_data_X = X_test.to_numpy()

gd.fit(train_data_X,y_train)

print(mOLS,bOLS)
gdParameters = gd.getParameters()
print(gdParameters[0], gdParameters[1])

y_pred_gd = []
for i in train_data_X:
  y_pred_gd.append(gd.predict(i))
y_pred_gd = np.array(y_pred_gd)
print(y_pred_gd)

plt.scatter(X,y)
plt.plot(X_train,lr.predict(X_train),color='red',linewidth=3)
plt.plot(train_data_X,y_pred_gd,color='black')
plt.show()

