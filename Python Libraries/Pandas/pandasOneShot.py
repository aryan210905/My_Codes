# -*- coding: utf-8 -*-
"""pandasOneShot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rxpwBFaP8jHs3ZuMSeLZCdUSqrAFCx3Y
"""

import pandas as pd

"""Series: A Pandas Series is like a column in a table. It is a one-dimensional array holding data of any type.

"""

series = pd.Series([1,2,3,4,5])

print(series)

# we can give custom indices by index=[list of indices]
data = [44,55,66,77,88]
indices = ['Ekta','Jayani','Diyanshi','Tanisha','Roshni']
series = pd.Series(data,index=indices)

print(series)

# we can also create series by dictionaries
data = {
    'Ekta' : 44,
    'Jayani' : 55,
    'Diyanshi' : 66,
    'Tanisha' : 77,
    'Roshni' : 88
}
series = pd.Series(data)
print(series)

# indexing in series
print(series['Ekta'])

print(series[4]) # we can also access by normal default indexing but it can give warning

"""DataFrames: Data frames in Pandas are usually multi-dimensional tables, called DataFrames.Series is like a column, a DataFrame is the whole table. Dataframes can have different dtypes for each column but 2D arrays canno"""

data = [[1,2,'a'],[4,5,'b'],[3,6,'c']]
df = pd.DataFrame(data)
print(df)

# we can give custom column and row names by columns=[list of column names] and index = [list of row names]
data = [[1,2,'a'],[4,5,'b'],[3,6,'c']]
df = pd.DataFrame(data,columns=['col1','col2','col3'],index=['row1','row2','row3'])
print(df)

df = pd.read_csv('D:\CODING_CODES\AIML\Python Libraries\Pandas\Files\obesity_prediction.csv')

print(df)

print(df.to_string())

print(df.columns) # returns names of columns

print(df.index) # returns names of rows
# if rows are numerical and in range then it returns a RangeIndex object

print(df.head())   # prints first 5 rows
# to get x number of first rows, use .head(x)

print(df.tail()) # prints last 5 rows
# to get x number of last rows, use .tail(x)

print(df.sample())  # prints a random data row
# for more than 1 random rows, .sample(number)

print(df.shape) # returns rows x cols of data set

print(df.size) #returns number of elements in dataset

print(df.info()) # returns columns dtypes, number of non null values etc

print(df.describe()) # prints count, mean, standard deviation, etc of each column

# we can access element of a particular row and column by df.loc[row,columns]
print(df.loc[0,'Age'])

# for multiple sequential rows, we use slicing
print(df.loc[0:5,'Age'])

# for multiple columns we can do the same
print(df.loc[0:5,'Age':'NCP'])

# we can access particular rows and cols by passing them in lists
print(df.loc[[0,5,7],['Age','family_history','FCVC']])

# loc is inclusive i.e. while slicing 5:9 both 5 and 9 are included

# if we want to access columns by their index and not their names, we use iloc
# iloc is exclusive of last row i.e. in 5:9 9th index values are not included
print(df.iloc[0:9,0])

# for multiple columns
print(df.iloc[0:9,0:5])

# .at[] and .iat are similar to .loc[] and .iloc[] but they only return 1 row
# for multiple rows they give errors
print(df.at[4,'Age'])

print(df.iat[4,3])

# in loc and iloc, if we do not give columns like .loc[0:5] then we will get for all columns
# to give only columns and not rows we need to do it like .loc[:,0:7]
# but if we do the same in at and iat then it will give error

# filtering via loc
print(df.loc[df['Height']>1])

# multiple conditions
print(df.loc[(df['Weight']>70) & (df['Gender']=='Male')])

print(df.loc[(df['Weight']>70) | (df['Height']>=1.9)])

# we can do this in a shorter way by
print(df[df['Age']>25])

# updating via loc
df.loc[1,'Age']=50

print(df.head())

# updating multiple rows
df.loc[0:3,'Gender'] = 'Not known'

print(df.head())

# adding new columns
df['Pincode'] = 395010

print(df.head())

# we can also initiate new column by nan values
import numpy as np
df['Employeed'] = np.nan
print(df.head())

# we can delete a column by drop
# axis = 1 for deleting column
# axis = 0 for deleting row
# we make inplace = True to actaully change it in the dataframe along the code
df.drop('Pincode',axis=1,inplace=True)
print(df.head())

# to create column at a particular position
# insert(index,colName,defaultValue)
df.insert(4,'Married','False')
print(df.head())

# we can also delete by del keyword
del df['Married']

print(df.head())

# rename column
df.rename(columns={'SMOKE':'Smoking?'},inplace=True)
print(df.head())

# handling null values
df = pd.read_csv('D:\CODING_CODES\AIML\Python Libraries\Pandas\Files\ml_null_handling_dataset.csv')
print(df.head())

print(df.to_string())

print(df.isna())  # returns same sized dataframe with values true if is null or false if is non null

print(df.isna().sum())  # returns sum of all null values for each column

print(df.to_string())

# to handle null values we use fillna(value,inplace)
df = pd.read_csv('D:\CODING_CODES\AIML\Python Libraries\Pandas\Files\ml_null_handling_dataset.csv')
df['Age'] = df['Age'].fillna(0)
print(df.to_string())

df['Education_Level'] = df['Education_Level'].fillna('No Education')
print(df.to_string())

df['Salary'] = df['Salary'].fillna(df['Salary'].mean())
print(df.to_string())

df = pd.read_csv('D:\CODING_CODES\AIML\Python Libraries\Pandas\Files\ml_null_handling_dataset.csv')

print(df.to_string())

print(df.head())

# updating multiple values
df.fillna({'Age':'0','Salary':df['Salary'].mean(),'Experience_Years':-1,'Education_Level':'No Education','Department':'No department'},inplace=True)

print(df.to_string())

# we can delete rows which are null by dropna
df = pd.read_csv('D:\CODING_CODES\AIML\Python Libraries\Pandas\Files\ml_null_handling_dataset.csv')
print(df.head())

df.dropna(inplace=True)
print(df.head())







