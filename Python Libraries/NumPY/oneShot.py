# -*- coding: utf-8 -*-
"""session-13-numpy-fundamentals.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GEkNfxnCPfzX8TCymkZJvWbkpGKZRgiK

### What is numpy?

NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.


At the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types

### Numpy Arrays Vs Python Sequences

- NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an ndarray will create a new array and delete the original.

- The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory.

- NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Pythonâ€™s built-in sequences.

- A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays.

### Creating Numpy Arrays
"""


'''
basics
np.array([]) -> 1d 
np.array([[]]) -> 2d
np.array([[[]]]) -> 3d
'''
# np.array
import numpy as np

a = np.array([1,2,3])
print(a)

# 2D 
b = np.array([[1,2,3],[4,5,6]])
print(b)

# 3D
c = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])
print(c)

# creating array of different dtypes
print(np.array([1,2,3],dtype=float))
print(np.array([1,2,3],dtype = bool))

'''
initialising with particular values
np.arange(start, stop, jump) -> array of start to stop-1 with given jump
np.zeroes(shape) -> array of only zeroes of given shape
np.ones(shape) -> array of only ones of given shape
np.random.random(shape) -> array of given shape with values in float b/w 0 and 1
np.linspace(start,stop,amount) -> array of given amount elements from start to stop with 
                                  equally spaces elements
np.identity(rows) -> identity matrix of given rows                      
'''
# np.arange: creates array of given range 
# from first to second-1 with a jump of third value
print(np.arange(1,11,2))

# with reshape
print(np.arange(16).reshape(2,2,2,2))

# np.ones(shape): creates array of only ones with given shape
print(np.ones((3,4)))
# np.zeroes(shape) creates array of only zeroes with given shape
print(np.zeros((3,4)))

# np.random.random(shape): creates array of given shape of random
# values between 0 and 1
print(np.random.random((3,4)))

# np.linspace(start,end,amount)
# creates array of given range from start to end of given amount which are equally spaced
print(np.linspace(-10,10,10,dtype=int))

# np.identity(shape): creates identity matrix of given rows
print(np.identity(3))


"""### Array Attributes"""

a1 = np.arange(10,dtype=np.int32)
a2 = np.arange(12,dtype=float).reshape(3,4)
a3 = np.arange(8).reshape(2,2,2)

print(a1)
print(a2)
print(a3)

# ndim: number of dimensions
print(a1.ndim)
print(a2.ndim)
print(a3.ndim)

# shape
print(a3.shape)
print(a3)

# size: no of elements
print(a2.size)
print(a2)

# itemsize: space occupied by each element of array in bytes
print(a3.itemsize)

# dtype: data type of elements in array
print(a1.dtype)
print(a2.dtype)
print(a3.dtype)

"""### Changing Datatype"""

# astype(newDtype): changes data type to new dtype
print(a3.astype(np.int32))

"""### Array Operations"""

a1 = np.arange(12).reshape(3,4)
a2 = np.arange(12,24).reshape(3,4)

print(a2)

# scalar operations

# arithmetic
print(a1 ** 2)

# relational
print(a2 > 15)
print(a2 == 15)

# vector operations
# arithmetic
print(a1 ** a2)

"""### Array Functions"""

a1 = np.random.random((3,3))
a1 = np.round(a1*100)
print(a1)

# max/min/sum/prod
print(np.max(a1))
print(np.min(a1))
print(np.sum(a1))
print(np.prod(a1))
# to get rowwise or columnwise max/min/sum/prod we use axis=0 or axis=1
# 0 -> col and 1 -> row
print(np.prod(a1,axis=0))

# mean/median/std/var
print(np.mean(a1))
print(np.median(a1))
print(np.std(a1))
print(np.var(a1))

# trigonomoetric functions
print(np.sin(a1))

# dot product: matrix multiplication
a2 = np.arange(12).reshape(3,4)
a3 = np.arange(12,24).reshape(4,3)

print(np.dot(a2,a3))

# log and exponents
print(np.exp(a1))

# round/floor/ceil

print(np.ceil(np.random.random((2,3))*100))

"""### Indexing and Slicing"""

a1 = np.arange(10)
a2 = np.arange(12).reshape(3,4)
a3 = np.arange(8).reshape(2,2,2)

print(a3)

print(a1)

print(a2)

# fetch particular value from 1d array
print(a1[3])

# fetch particular value from matrix
print(a2[1,0])

print(a3)

print(a3[1,0,1])

print(a3[1,1,0])

print(a1)

print(a1[2:5:2])

print(a2)

print(a2[0:2,1::2])

print(a2[::2,1::2])

print(a2[1,::3])

print(a2[0,:])

print(a2[:,2])

print(a2[1:,1:3])

a3 = np.arange(27).reshape(3,3,3)
print(a3)

print(a3[::2,0,::2])

print(a3[2,1:,1:])

print(a3[0,1,:])











"""### Iterating"""

print(a1)

for i in a1:
  print(i)

print(a2)

for i in a2:
  print(i)

print(a3)

for i in a3:
  print(i)

for i in np.nditer(a3):
  print(i)

"""### Reshaping"""

# reshape

# Transpose
np.transpose(a2)
print(a2.T)

# ravel
print(a3.ravel())

"""### Stacking"""

# horizontal stacking
a4 = np.arange(12).reshape(3,4)
a5 = np.arange(12,24).reshape(3,4)
print(a5)

print(np.hstack((a4,a5)))

# Vertical stacking
print(np.vstack((a4,a5)))

"""### Splitting"""

# horizontal splitting
print(a4)

print(np.hsplit(a4,2))

# vertical splitting

print(a5)

print(np.vsplit(a5,3))

